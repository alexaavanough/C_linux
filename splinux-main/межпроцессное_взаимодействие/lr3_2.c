/************************************************************************************************************************
* Разработать приложение, объединяющее 3 процесса в конвейер (родитель и два потомка, левый и правый),				    *
* в котором поток стандартного вывода левого потомка соединен через канал с потоком стандартного ввода правого потомка. *
* В левом и правом потомке д.б. предусмотрена возможность вызова (через exec) произвольных программ.					*
* Для демонстрации работы приложения реализовать выполнение в конвейере команды											*
* "ps ax | grep PID", где PID — идентификатор родительского процесса.													*
************************************************************************************************************************/

#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

extern char **environ;

int main() {
    pid_t pid_l, pid_r;
	/* Создание неименованного канала */
    int pipe_lr[2], status;
    if (pipe(pipe_lr) < 0) {
        perror("error on pipe");
        exit(1);
    }

	/* Создание двух процессов */
    pid_l = fork();
    if (pid_l < 0) {
        perror("error on fork");
        return 1;
    }
	if (pid_l != 0)
	{
		pid_r = fork();
		if (pid_r < 0) {
			perror("error on fork");
			return 1;
		}
	}
    

	/*** Left ***/
    if (pid_l == 0) {
		/* Перенаправление стандартного потока вывода в "конец" для записи неименованного канала */
        close(pipe_lr[0]);  /* Закрытие конца для чтения канала */
        close(1); /* Закрытие стандартного потока вывода (освобождение ФД №1) */
        dup(pipe_lr[1]); /* Дублирование "конца" для записи неименованного канал (он покадёт в ФД №1, т.е. stdout) */
        close(pipe_lr[1]); /* Закрытие "конца" для записи неименованного канала */ 
		
		/* Выполнение ps aux */
        char *args[] = {"ps", "aux", 0};
        if (execv("/bin/ps", args) < 0) {
            perror("Error on execve1");
            exit(1);
        }
        exit(0);
    }
	/************/

	/*** Right ***/
    if (pid_r == 0) {
		/* Перенаправление стандартного потока ввода в "конец" для чтения неименованного канала */
        close(pipe_lr[1]); /* Закрытие конца для записи канала */
        close(0); /* Закрытие стандартного потока ввода (освобождение ФД №0) */
        dup(pipe_lr[0]); /* Дублирование "конца" для чтения неименованного канал (он покадёт в ФД №0, т.е. stdin) */
        close(pipe_lr[0]); /* Закрытие "конца" для чтения неименованного канала */ 
		
		/* Выполнение grep <PPID> */
        char ppid[5];
        sprintf(ppid, "%d", getppid());
        char *args[] = {"grep", ppid, 0};
        waitpid(pid_l, &status, WUNTRACED | WCONTINUED); /* Дождаться окончания работы первого процесса */
        if (execv("/bin/grep", args) < 0) {
            perror("error on execve2");
            exit(1);
        }
		
        exit(0);
    }
	/*************/

    wait(&status);
    return 0;
}

